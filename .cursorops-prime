#!/usr/bin/env bash
# CursorOps-Prime: Production Engineer + Codegen Pair
# Anti-Fraud Platform Command System

set -euo pipefail

# Project Configuration
PROJECT_NAME="antifraud-platform"
ORG_NAME="acme"
DOMAIN_ROOT="yourdomain.com"
WEB_SUBDOMAIN="app"
API_SUBDOMAIN="api"
REGION="us-east-1"

# Color codes for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Logging functions
log_info() { echo -e "${BLUE}â„¹ï¸  $1${NC}"; }
log_success() { echo -e "${GREEN}âœ… $1${NC}"; }
log_warning() { echo -e "${YELLOW}âš ï¸  $1${NC}"; }
log_error() { echo -e "${RED}âŒ $1${NC}"; }

# Check if command exists
command_exists() {
    command -v "$1" >/dev/null 2>&1
}

# Install missing dependencies
install_deps() {
    if ! command_exists pnpm; then
        log_info "Installing pnpm..."
        npm install -g pnpm
    fi
    
    if ! command_exists python3; then
        log_error "Python 3.12+ required. Please install Python first."
        exit 1
    fi
    
    if ! command_exists docker; then
        log_warning "Docker not found. Some features may not work."
    fi
}

# Step 0: Bootstrap repo + hygiene
bootstrap() {
    log_info "ðŸ§± Bootstrapping ${PROJECT_NAME}..."
    
    # Install dependencies
    install_deps
    
    # Ensure git is initialized
    if [ ! -d ".git" ]; then
        git init -b main
    fi
    
    # Set up git LFS
    git lfs install || true
    
    # Create essential directories
    mkdir -p {infra/db,scripts,.github/workflows}
    
    log_success "Bootstrap complete"
}

# Step 1: Monorepo scaffold (verify existing structure)
scaffold() {
    log_info "ðŸ—ï¸  Verifying monorepo structure..."
    
    # Check if all components exist
    [ -d "web" ] || { log_error "Web directory missing"; exit 1; }
    [ -d "platform/api" ] || { log_error "API directory missing"; exit 1; }
    [ -d "platform/mobile" ] || { log_error "Mobile directory missing"; exit 1; }
    
    log_success "Monorepo structure verified"
}

# Step 2: Environment setup
env_setup() {
    log_info "ðŸ”§ Setting up environment files..."
    
    # Create .env.example files if they don't exist
    [ -f "web/.env.example" ] || cat > web/.env.example << 'EOF'
# Next.js Environment Variables
NEXT_PUBLIC_API_URL=http://localhost:8000
NEXT_PUBLIC_APP_URL=http://localhost:3000
NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=your_clerk_key_here
CLERK_SECRET_KEY=your_clerk_secret_here
NEXT_PUBLIC_SENTRY_DSN=your_sentry_dsn_here
EOF

    [ -f "platform/api/.env.example" ] || cat > platform/api/.env.example << 'EOF'
# FastAPI Environment Variables
DATABASE_URL=postgresql://user:password@localhost:5432/antifraud
REDIS_URL=redis://localhost:6379
SECRET_KEY=your_secret_key_here
SENTRY_DSN=your_sentry_dsn_here
ENVIRONMENT=development
EOF

    [ -f "platform/mobile/.env.example" ] || cat > platform/mobile/.env.example << 'EOF'
# Expo Environment Variables
EXPO_PUBLIC_API_URL=http://localhost:8000
EXPO_PUBLIC_APP_URL=https://yourdomain.com
EOF

    log_success "Environment files created"
}

# Step 3: Database setup
db_setup() {
    log_info "ðŸ—„ï¸  Setting up database..."
    
    # Run existing database setup
    if [ -f "run_db_setup.sh" ]; then
        chmod +x run_db_setup.sh
        ./run_db_setup.sh
    else
        log_warning "Database setup script not found, skipping..."
    fi
    
    log_success "Database setup complete"
}

# Step 4: API skeleton (verify existing)
api_setup() {
    log_info "ðŸš€ Verifying API setup..."
    
    # Check if API is properly configured
    if [ -f "platform/api/src/main.py" ]; then
        log_success "API structure verified"
    else
        log_error "API main.py not found"
        exit 1
    fi
}

# Step 5: Web scaffold (verify existing)
web_setup() {
    log_info "ðŸŒ Verifying web setup..."
    
    # Check if web app is properly configured
    if [ -f "web/package.json" ]; then
        log_success "Web structure verified"
    else
        log_error "Web package.json not found"
        exit 1
    fi
}

# Step 6: Mobile scaffold (verify existing)
mobile_setup() {
    log_info "ðŸ“± Verifying mobile setup..."
    
    # Check if mobile app is properly configured
    if [ -f "platform/mobile/package.json" ]; then
        log_success "Mobile structure verified"
    else
        log_error "Mobile package.json not found"
        exit 1
    fi
}

# Step 7: CI/CD setup
cicd_setup() {
    log_info "ðŸ”„ Setting up CI/CD..."
    
    # Create GitHub Actions workflows
    mkdir -p .github/workflows
    
    # Web deployment workflow
    cat > .github/workflows/web-deploy.yml << 'EOF'
name: Deploy Web to Vercel
on:
  push:
    branches: [main]
    paths: ['web/**']
  pull_request:
    branches: [main]
    paths: ['web/**']

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'pnpm'
      
      - name: Install pnpm
        run: npm install -g pnpm
      
      - name: Install dependencies
        run: pnpm install --frozen-lockfile
        working-directory: ./web
      
      - name: Build
        run: pnpm run build
        working-directory: ./web
        env:
          NEXT_PUBLIC_API_URL: ${{ secrets.NEXT_PUBLIC_API_URL }}
          NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY: ${{ secrets.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY }}
          CLERK_SECRET_KEY: ${{ secrets.CLERK_SECRET_KEY }}
      
      - name: Deploy to Vercel
        uses: amondnet/vercel-action@v25
        with:
          vercel-token: ${{ secrets.VERCEL_TOKEN }}
          vercel-org-id: ${{ secrets.VERCEL_ORG_ID }}
          vercel-project-id: ${{ secrets.VERCEL_PROJECT_ID }}
          working-directory: ./web
EOF

    # API deployment workflow
    cat > .github/workflows/api-deploy.yml << 'EOF'
name: Deploy API to Railway
on:
  push:
    branches: [main]
    paths: ['platform/api/**']
  pull_request:
    branches: [main]
    paths: ['platform/api/**']

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v4
        with:
          python-version: '3.12'
      
      - name: Install dependencies
        run: |
          cd platform/api
          pip install -r requirements.txt
          pip install -r requirements-dev.txt
      
      - name: Run tests
        run: |
          cd platform/api
          python -m pytest tests/ -v
        env:
          DATABASE_URL: postgresql://test:test@localhost:5432/test
      
      - name: Deploy to Railway
        if: github.ref == 'refs/heads/main'
        uses: bervProject/railway-deploy@v1.0.4
        with:
          railway-token: ${{ secrets.RAILWAY_TOKEN }}
          service: ${{ secrets.RAILWAY_SERVICE }}
EOF

    # Mobile build workflow
    cat > .github/workflows/mobile-build.yml << 'EOF'
name: Build Mobile App
on:
  push:
    branches: [main]
    paths: ['platform/mobile/**']
  pull_request:
    branches: [main]
    paths: ['platform/mobile/**']

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'pnpm'
      
      - name: Install pnpm
        run: npm install -g pnpm
      
      - name: Install dependencies
        run: pnpm install --frozen-lockfile
        working-directory: ./platform/mobile
      
      - name: Setup Expo
        uses: expo/expo-github-action@v8
        with:
          expo-version: latest
          token: ${{ secrets.EXPO_TOKEN }}
      
      - name: Build Android
        run: |
          cd platform/mobile
          npx eas build --platform android --non-interactive
        env:
          EXPO_TOKEN: ${{ secrets.EXPO_TOKEN }}
      
      - name: Build iOS
        run: |
          cd platform/mobile
          npx eas build --platform ios --non-interactive
        env:
          EXPO_TOKEN: ${{ secrets.EXPO_TOKEN }}
EOF

    log_success "CI/CD workflows created"
}

# Step 8: Observability setup
obs_setup() {
    log_info "ðŸ“Š Setting up observability..."
    
    # Create Sentry configuration if not exists
    if [ ! -f "platform/api/sentry.py" ]; then
        cat > platform/api/sentry.py << 'EOF'
import sentry_sdk
from sentry_sdk.integrations.fastapi import FastApiIntegration
from sentry_sdk.integrations.sqlalchemy import SqlalchemyIntegration
import os

def init_sentry():
    sentry_dsn = os.getenv("SENTRY_DSN")
    if sentry_dsn:
        sentry_sdk.init(
            dsn=sentry_dsn,
            integrations=[
                FastApiIntegration(auto_enabling_instrumentations=True),
                SqlalchemyIntegration(),
            ],
            traces_sample_rate=0.1,
            environment=os.getenv("ENVIRONMENT", "development"),
        )
EOF
    fi
    
    log_success "Observability setup complete"
}

# Step 9: SLO + Auto-rollback
slo_setup() {
    log_info "ðŸŽ¯ Setting up SLO monitoring..."
    
    # Create SLO configuration
    cat > platform/api/slo_config.py << 'EOF'
from dataclasses import dataclass
from typing import Dict, Any
import time
import asyncio
from datetime import datetime, timedelta

@dataclass
class SLOConfig:
    p99_9_latency_ms: int = 400
    error_rate_threshold: float = 0.001  # 0.1%
    error_budget_window_hours: int = 24
    max_errors_per_window: int = 100
    
    def check_latency_slo(self, latency_ms: float) -> bool:
        return latency_ms <= self.p99_9_latency_ms
    
    def check_error_rate_slo(self, errors: int, total_requests: int) -> bool:
        if total_requests == 0:
            return True
        error_rate = errors / total_requests
        return error_rate <= self.error_rate_threshold

class SLOMonitor:
    def __init__(self, config: SLOConfig):
        self.config = config
        self.metrics = {
            'requests': 0,
            'errors': 0,
            'latencies': []
        }
    
    async def record_request(self, latency_ms: float, is_error: bool = False):
        self.metrics['requests'] += 1
        if is_error:
            self.metrics['errors'] += 1
        self.metrics['latencies'].append(latency_ms)
        
        # Check SLO violations
        if not self.config.check_latency_slo(latency_ms):
            await self._handle_slo_violation('latency', latency_ms)
        
        if not self.config.check_error_rate_slo(self.metrics['errors'], self.metrics['requests']):
            await self._handle_slo_violation('error_rate', self.metrics['errors'] / self.metrics['requests'])
    
    async def _handle_slo_violation(self, violation_type: str, value: float):
        # In production, this would trigger rollback procedures
        print(f"ðŸš¨ SLO VIOLATION: {violation_type} = {value}")
        # TODO: Implement actual rollback logic
EOF

    log_success "SLO monitoring configured"
}

# Step 10: Incident timeline
incident_setup() {
    log_info "ðŸš¨ Setting up incident management..."
    
    # Create incident management system
    cat > platform/api/incident_manager.py << 'EOF'
from datetime import datetime
from typing import List, Dict, Any
from dataclasses import dataclass
import json

@dataclass
class Incident:
    id: str
    title: str
    severity: str  # critical, high, medium, low
    status: str    # open, investigating, resolved
    created_at: datetime
    resolved_at: datetime = None
    timeline: List[Dict[str, Any]] = None
    
    def __post_init__(self):
        if self.timeline is None:
            self.timeline = []

class IncidentManager:
    def __init__(self):
        self.incidents: List[Incident] = []
    
    def create_incident(self, title: str, severity: str) -> Incident:
        incident = Incident(
            id=f"INC-{len(self.incidents) + 1:04d}",
            title=title,
            severity=severity,
            status="open",
            created_at=datetime.utcnow()
        )
        self.incidents.append(incident)
        return incident
    
    def add_timeline_event(self, incident_id: str, event: str, details: str = ""):
        incident = next((i for i in self.incidents if i.id == incident_id), None)
        if incident:
            incident.timeline.append({
                "timestamp": datetime.utcnow().isoformat(),
                "event": event,
                "details": details
            })
    
    def resolve_incident(self, incident_id: str):
        incident = next((i for i in self.incidents if i.id == incident_id), None)
        if incident:
            incident.status = "resolved"
            incident.resolved_at = datetime.utcnow()
            self.add_timeline_event(incident_id, "Incident resolved")
EOF

    log_success "Incident management configured"
}

# Step 11: Audit timeline + Stabilize mode
audit_setup() {
    log_info "ðŸ” Setting up audit timeline..."
    
    # Create audit system
    cat > platform/api/audit_logger.py << 'EOF'
from datetime import datetime
from typing import Dict, Any, Optional, List
import json
import uuid

class AuditLogger:
    def __init__(self):
        self.audit_events = []
    
    def log_event(self, 
                  action: str, 
                  resource: str, 
                  user_id: Optional[str] = None,
                  details: Optional[Dict[str, Any]] = None):
        event = {
            "id": str(uuid.uuid4()),
            "timestamp": datetime.utcnow().isoformat(),
            "action": action,
            "resource": resource,
            "user_id": user_id,
            "details": details or {}
        }
        self.audit_events.append(event)
        return event["id"]
    
    def get_audit_trail(self, resource: Optional[str] = None, 
                       user_id: Optional[str] = None) -> List[Dict[str, Any]]:
        events = self.audit_events
        
        if resource:
            events = [e for e in events if e["resource"] == resource]
        
        if user_id:
            events = [e for e in events if e["user_id"] == user_id]
        
        return sorted(events, key=lambda x: x["timestamp"], reverse=True)

class StabilizeMode:
    def __init__(self):
        self.is_active = False
        self.rps_limit = 1000
        self.circuit_breaker_threshold = 0.1
    
    def activate(self, rps_limit: int = 1000):
        self.is_active = True
        self.rps_limit = rps_limit
        print("ðŸ›¡ï¸  Stabilize mode activated")
    
    def deactivate(self):
        self.is_active = False
        print("âœ… Stabilize mode deactivated")
    
    def should_throttle(self, current_rps: float) -> bool:
        return self.is_active and current_rps > self.rps_limit
EOF

    log_success "Audit and stabilize mode configured"
}

# Step 12: Production hardening
prod_setup() {
    log_info "ðŸ”’ Setting up production hardening..."
    
    # Create production configuration
    cat > platform/api/prod_config.py << 'EOF'
import os
from typing import Dict, Any

class ProductionConfig:
    def __init__(self):
        self.waf_rules = {
            "rate_limit_per_ip": 1000,  # requests per hour
            "max_request_size": 10 * 1024 * 1024,  # 10MB
            "blocked_headers": ["x-forwarded-for", "x-real-ip"],
            "allowed_origins": os.getenv("ALLOWED_ORIGINS", "").split(",")
        }
        
        self.backup_config = {
            "frequency": "daily",
            "retention_days": 30,
            "encryption": True,
            "pitr_enabled": True
        }
        
        self.pii_policies = {
            "retention_days": 90,
            "encryption_at_rest": True,
            "anonymization_after": 30
        }
    
    def get_waf_rules(self) -> Dict[str, Any]:
        return self.waf_rules
    
    def get_backup_config(self) -> Dict[str, Any]:
        return self.backup_config
    
    def get_pii_policies(self) -> Dict[str, Any]:
        return self.pii_policies

# Launch checklist
LAUNCH_CHECKLIST = [
    "âœ… Environment variables configured",
    "âœ… Database migrations applied",
    "âœ… SSL certificates valid",
    "âœ… Monitoring alerts configured",
    "âœ… Backup procedures tested",
    "âœ… Rollback procedures tested",
    "âœ… Load testing completed",
    "âœ… Security scan passed",
    "âœ… Documentation updated",
    "âœ… Team trained on procedures"
]
EOF

    log_success "Production hardening configured"
}

# Development scripts
dev_scripts() {
    log_info "ðŸ› ï¸  Creating development scripts..."
    
    # Create comprehensive dev script
    cat > scripts/dev.sh << 'EOF'
#!/usr/bin/env bash
set -euo pipefail

echo "ðŸš€ Starting Anti-Fraud Platform Development Environment"

# Check dependencies
command -v pnpm >/dev/null || { echo "âŒ pnpm not found. Install with: npm install -g pnpm"; exit 1; }
command -v python3 >/dev/null || { echo "âŒ Python 3 not found"; exit 1; }

# Install dependencies
echo "ðŸ“¦ Installing dependencies..."
pnpm install
cd platform/api && pip install -r requirements.txt && cd ../..
cd platform/mobile && pnpm install && cd ../..

# Start services
echo "ðŸŒ Starting web app..."
cd web && pnpm dev &
WEB_PID=$!

echo "ðŸš€ Starting API server..."
cd platform/api && python -m uvicorn src.main:app --reload --host 0.0.0.0 --port 8000 &
API_PID=$!

echo "ðŸ“± Starting mobile app..."
cd platform/mobile && pnpm start &
MOBILE_PID=$!

echo "âœ… All services started!"
echo "ðŸŒ Web: http://localhost:3000"
echo "ðŸš€ API: http://localhost:8000"
echo "ðŸ“± Mobile: Check terminal for Expo QR code"

# Cleanup function
cleanup() {
    echo "ðŸ›‘ Shutting down services..."
    kill $WEB_PID $API_PID $MOBILE_PID 2>/dev/null || true
    exit 0
}

trap cleanup SIGINT SIGTERM

# Wait for services
wait
EOF

    chmod +x scripts/dev.sh
    
    # Create test script
    cat > scripts/test.sh << 'EOF'
#!/usr/bin/env bash
set -euo pipefail

echo "ðŸ§ª Running Anti-Fraud Platform Tests"

# API tests
echo "ðŸ”¬ Running API tests..."
cd platform/api && python -m pytest tests/ -v --cov=src

# E2E tests
echo "ðŸŽ­ Running E2E tests..."
cd ../.. && npx playwright test

# Mobile tests
echo "ðŸ“± Running mobile tests..."
cd platform/mobile && pnpm test

echo "âœ… All tests completed!"
EOF

    chmod +x scripts/test.sh
    
    log_success "Development scripts created"
}

# Main execution function
main() {
    case "${1:-help}" in
        "init")
            bootstrap
            scaffold
            env_setup
            dev_scripts
            ;;
        "api")
            api_setup
            db_setup
            ;;
        "web")
            web_setup
            ;;
        "mobile")
            mobile_setup
            ;;
        "cicd")
            cicd_setup
            ;;
        "obs/slo")
            obs_setup
            slo_setup
            ;;
        "inc/audit/stab")
            incident_setup
            audit_setup
            ;;
        "prod")
            prod_setup
            ;;
        "run all")
            bootstrap
            scaffold
            env_setup
            db_setup
            api_setup
            web_setup
            mobile_setup
            cicd_setup
            obs_setup
            slo_setup
            incident_setup
            audit_setup
            prod_setup
            dev_scripts
            log_success "ðŸŽ‰ Full platform setup complete!"
            ;;
        "help"|*)
            echo "Usage: $0 {init|api|web|mobile|cicd|obs/slo|inc/audit/stab|prod|run all}"
            echo ""
            echo "Commands:"
            echo "  init              - Bootstrap repo + hygiene + env stubs"
            echo "  api               - API skeleton + database setup"
            echo "  web               - Web scaffold verification"
            echo "  mobile            - Mobile scaffold verification"
            echo "  cicd              - CI/CD workflows"
            echo "  obs/slo           - Observability + SLO monitoring"
            echo "  inc/audit/stab    - Incident + audit + stabilize mode"
            echo "  prod              - Production hardening"
            echo "  run all           - Execute full pipeline"
            ;;
    esac
}

# Run main function with all arguments
main "$@"
