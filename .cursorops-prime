#!/usr/bin/env bash
# CursorOps-Prime: Production Engineer + Codegen Pair
# Anti-Fraud Platform Command System

set -euo pipefail

# Project Configuration
PROJECT_NAME="antifraud-platform"
ORG_NAME="acme"
DOMAIN_ROOT="yourdomain.com"
WEB_SUBDOMAIN="app"
API_SUBDOMAIN="api"
REGION="us-east-1"

# Color codes for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Logging functions
log_info() { echo -e "${BLUE}ℹ️  $1${NC}"; }
log_success() { echo -e "${GREEN}✅ $1${NC}"; }
log_warning() { echo -e "${YELLOW}⚠️  $1${NC}"; }
log_error() { echo -e "${RED}❌ $1${NC}"; }

# Check if command exists
command_exists() {
    command -v "$1" >/dev/null 2>&1
}

# Install missing dependencies
install_deps() {
    if ! command_exists pnpm; then
        log_info "Installing pnpm..."
        npm install -g pnpm
    fi
    
    if ! command_exists python3; then
        log_error "Python 3.12+ required. Please install Python first."
        exit 1
    fi
    
    if ! command_exists docker; then
        log_warning "Docker not found. Some features may not work."
    fi
}

# Step 0: Bootstrap repo + hygiene
bootstrap() {
    log_info "🧱 Bootstrapping ${PROJECT_NAME}..."
    
    # Install dependencies
    install_deps
    
    # Ensure git is initialized
    if [ ! -d ".git" ]; then
        git init -b main
    fi
    
    # Set up git LFS
    git lfs install || true
    
    # Create essential directories
    mkdir -p {infra/db,scripts,.github/workflows}
    
    log_success "Bootstrap complete"
}

# Step 1: Monorepo scaffold (verify existing structure)
scaffold() {
    log_info "🏗️  Verifying monorepo structure..."
    
    # Check if all components exist
    [ -d "web" ] || { log_error "Web directory missing"; exit 1; }
    [ -d "platform/api" ] || { log_error "API directory missing"; exit 1; }
    [ -d "platform/mobile" ] || { log_error "Mobile directory missing"; exit 1; }
    
    log_success "Monorepo structure verified"
}

# Step 2: Environment setup
env_setup() {
    log_info "🔧 Setting up environment files..."
    
    # Create .env.example files if they don't exist
    [ -f "web/.env.example" ] || cat > web/.env.example << 'EOF'
# Next.js Environment Variables
NEXT_PUBLIC_API_URL=http://localhost:8000
NEXT_PUBLIC_APP_URL=http://localhost:3000
NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=your_clerk_key_here
CLERK_SECRET_KEY=your_clerk_secret_here
NEXT_PUBLIC_SENTRY_DSN=your_sentry_dsn_here
EOF

    [ -f "platform/api/.env.example" ] || cat > platform/api/.env.example << 'EOF'
# FastAPI Environment Variables
DATABASE_URL=postgresql://user:password@localhost:5432/antifraud
REDIS_URL=redis://localhost:6379
SECRET_KEY=your_secret_key_here
SENTRY_DSN=your_sentry_dsn_here
ENVIRONMENT=development
EOF

    [ -f "platform/mobile/.env.example" ] || cat > platform/mobile/.env.example << 'EOF'
# Expo Environment Variables
EXPO_PUBLIC_API_URL=http://localhost:8000
EXPO_PUBLIC_APP_URL=https://yourdomain.com
EOF

    log_success "Environment files created"
}

# Step 3: Database setup
db_setup() {
    log_info "🗄️  Setting up database..."
    
    # Run existing database setup
    if [ -f "run_db_setup.sh" ]; then
        chmod +x run_db_setup.sh
        ./run_db_setup.sh
    else
        log_warning "Database setup script not found, skipping..."
    fi
    
    log_success "Database setup complete"
}

# Step 4: API skeleton (verify existing)
api_setup() {
    log_info "🚀 Verifying API setup..."
    
    # Check if API is properly configured
    if [ -f "platform/api/src/main.py" ]; then
        log_success "API structure verified"
    else
        log_error "API main.py not found"
        exit 1
    fi
}

# Step 5: Web scaffold (verify existing)
web_setup() {
    log_info "🌐 Verifying web setup..."
    
    # Check if web app is properly configured
    if [ -f "web/package.json" ]; then
        log_success "Web structure verified"
    else
        log_error "Web package.json not found"
        exit 1
    fi
}

# Step 6: Mobile scaffold (verify existing)
mobile_setup() {
    log_info "📱 Verifying mobile setup..."
    
    # Check if mobile app is properly configured
    if [ -f "platform/mobile/package.json" ]; then
        log_success "Mobile structure verified"
    else
        log_error "Mobile package.json not found"
        exit 1
    fi
}

# Step 7: CI/CD setup
cicd_setup() {
    log_info "🔄 Setting up CI/CD..."
    
    # Create GitHub Actions workflows
    mkdir -p .github/workflows
    
    # Web deployment workflow
    cat > .github/workflows/web-deploy.yml << 'EOF'
name: Deploy Web to Vercel
on:
  push:
    branches: [main]
    paths: ['web/**']
  pull_request:
    branches: [main]
    paths: ['web/**']

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'pnpm'
      
      - name: Install pnpm
        run: npm install -g pnpm
      
      - name: Install dependencies
        run: pnpm install --frozen-lockfile
        working-directory: ./web
      
      - name: Build
        run: pnpm run build
        working-directory: ./web
        env:
          NEXT_PUBLIC_API_URL: ${{ secrets.NEXT_PUBLIC_API_URL }}
          NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY: ${{ secrets.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY }}
          CLERK_SECRET_KEY: ${{ secrets.CLERK_SECRET_KEY }}
      
      - name: Deploy to Vercel
        uses: amondnet/vercel-action@v25
        with:
          vercel-token: ${{ secrets.VERCEL_TOKEN }}
          vercel-org-id: ${{ secrets.VERCEL_ORG_ID }}
          vercel-project-id: ${{ secrets.VERCEL_PROJECT_ID }}
          working-directory: ./web
EOF

    # API deployment workflow
    cat > .github/workflows/api-deploy.yml << 'EOF'
name: Deploy API to Railway
on:
  push:
    branches: [main]
    paths: ['platform/api/**']
  pull_request:
    branches: [main]
    paths: ['platform/api/**']

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v4
        with:
          python-version: '3.12'
      
      - name: Install dependencies
        run: |
          cd platform/api
          pip install -r requirements.txt
          pip install -r requirements-dev.txt
      
      - name: Run tests
        run: |
          cd platform/api
          python -m pytest tests/ -v
        env:
          DATABASE_URL: postgresql://test:test@localhost:5432/test
      
      - name: Deploy to Railway
        if: github.ref == 'refs/heads/main'
        uses: bervProject/railway-deploy@v1.0.4
        with:
          railway-token: ${{ secrets.RAILWAY_TOKEN }}
          service: ${{ secrets.RAILWAY_SERVICE }}
EOF

    # Mobile build workflow
    cat > .github/workflows/mobile-build.yml << 'EOF'
name: Build Mobile App
on:
  push:
    branches: [main]
    paths: ['platform/mobile/**']
  pull_request:
    branches: [main]
    paths: ['platform/mobile/**']

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'pnpm'
      
      - name: Install pnpm
        run: npm install -g pnpm
      
      - name: Install dependencies
        run: pnpm install --frozen-lockfile
        working-directory: ./platform/mobile
      
      - name: Setup Expo
        uses: expo/expo-github-action@v8
        with:
          expo-version: latest
          token: ${{ secrets.EXPO_TOKEN }}
      
      - name: Build Android
        run: |
          cd platform/mobile
          npx eas build --platform android --non-interactive
        env:
          EXPO_TOKEN: ${{ secrets.EXPO_TOKEN }}
      
      - name: Build iOS
        run: |
          cd platform/mobile
          npx eas build --platform ios --non-interactive
        env:
          EXPO_TOKEN: ${{ secrets.EXPO_TOKEN }}
EOF

    log_success "CI/CD workflows created"
}

# Step 8: Observability setup
obs_setup() {
    log_info "📊 Setting up observability..."
    
    # Create Sentry configuration if not exists
    if [ ! -f "platform/api/sentry.py" ]; then
        cat > platform/api/sentry.py << 'EOF'
import sentry_sdk
from sentry_sdk.integrations.fastapi import FastApiIntegration
from sentry_sdk.integrations.sqlalchemy import SqlalchemyIntegration
import os

def init_sentry():
    sentry_dsn = os.getenv("SENTRY_DSN")
    if sentry_dsn:
        sentry_sdk.init(
            dsn=sentry_dsn,
            integrations=[
                FastApiIntegration(auto_enabling_instrumentations=True),
                SqlalchemyIntegration(),
            ],
            traces_sample_rate=0.1,
            environment=os.getenv("ENVIRONMENT", "development"),
        )
EOF
    fi
    
    log_success "Observability setup complete"
}

# Step 9: SLO + Auto-rollback
slo_setup() {
    log_info "🎯 Setting up SLO monitoring..."
    
    # Create SLO configuration
    cat > platform/api/slo_config.py << 'EOF'
from dataclasses import dataclass
from typing import Dict, Any
import time
import asyncio
from datetime import datetime, timedelta

@dataclass
class SLOConfig:
    p99_9_latency_ms: int = 400
    error_rate_threshold: float = 0.001  # 0.1%
    error_budget_window_hours: int = 24
    max_errors_per_window: int = 100
    
    def check_latency_slo(self, latency_ms: float) -> bool:
        return latency_ms <= self.p99_9_latency_ms
    
    def check_error_rate_slo(self, errors: int, total_requests: int) -> bool:
        if total_requests == 0:
            return True
        error_rate = errors / total_requests
        return error_rate <= self.error_rate_threshold

class SLOMonitor:
    def __init__(self, config: SLOConfig):
        self.config = config
        self.metrics = {
            'requests': 0,
            'errors': 0,
            'latencies': []
        }
    
    async def record_request(self, latency_ms: float, is_error: bool = False):
        self.metrics['requests'] += 1
        if is_error:
            self.metrics['errors'] += 1
        self.metrics['latencies'].append(latency_ms)
        
        # Check SLO violations
        if not self.config.check_latency_slo(latency_ms):
            await self._handle_slo_violation('latency', latency_ms)
        
        if not self.config.check_error_rate_slo(self.metrics['errors'], self.metrics['requests']):
            await self._handle_slo_violation('error_rate', self.metrics['errors'] / self.metrics['requests'])
    
    async def _handle_slo_violation(self, violation_type: str, value: float):
        # In production, this would trigger rollback procedures
        print(f"🚨 SLO VIOLATION: {violation_type} = {value}")
        # TODO: Implement actual rollback logic
EOF

    log_success "SLO monitoring configured"
}

# Step 10: Incident timeline
incident_setup() {
    log_info "🚨 Setting up incident management..."
    
    # Create incident management system
    cat > platform/api/incident_manager.py << 'EOF'
from datetime import datetime
from typing import List, Dict, Any
from dataclasses import dataclass
import json

@dataclass
class Incident:
    id: str
    title: str
    severity: str  # critical, high, medium, low
    status: str    # open, investigating, resolved
    created_at: datetime
    resolved_at: datetime = None
    timeline: List[Dict[str, Any]] = None
    
    def __post_init__(self):
        if self.timeline is None:
            self.timeline = []

class IncidentManager:
    def __init__(self):
        self.incidents: List[Incident] = []
    
    def create_incident(self, title: str, severity: str) -> Incident:
        incident = Incident(
            id=f"INC-{len(self.incidents) + 1:04d}",
            title=title,
            severity=severity,
            status="open",
            created_at=datetime.utcnow()
        )
        self.incidents.append(incident)
        return incident
    
    def add_timeline_event(self, incident_id: str, event: str, details: str = ""):
        incident = next((i for i in self.incidents if i.id == incident_id), None)
        if incident:
            incident.timeline.append({
                "timestamp": datetime.utcnow().isoformat(),
                "event": event,
                "details": details
            })
    
    def resolve_incident(self, incident_id: str):
        incident = next((i for i in self.incidents if i.id == incident_id), None)
        if incident:
            incident.status = "resolved"
            incident.resolved_at = datetime.utcnow()
            self.add_timeline_event(incident_id, "Incident resolved")
EOF

    log_success "Incident management configured"
}

# Step 11: Audit timeline + Stabilize mode
audit_setup() {
    log_info "🔍 Setting up audit timeline..."
    
    # Create audit system
    cat > platform/api/audit_logger.py << 'EOF'
from datetime import datetime
from typing import Dict, Any, Optional, List
import json
import uuid

class AuditLogger:
    def __init__(self):
        self.audit_events = []
    
    def log_event(self, 
                  action: str, 
                  resource: str, 
                  user_id: Optional[str] = None,
                  details: Optional[Dict[str, Any]] = None):
        event = {
            "id": str(uuid.uuid4()),
            "timestamp": datetime.utcnow().isoformat(),
            "action": action,
            "resource": resource,
            "user_id": user_id,
            "details": details or {}
        }
        self.audit_events.append(event)
        return event["id"]
    
    def get_audit_trail(self, resource: Optional[str] = None, 
                       user_id: Optional[str] = None) -> List[Dict[str, Any]]:
        events = self.audit_events
        
        if resource:
            events = [e for e in events if e["resource"] == resource]
        
        if user_id:
            events = [e for e in events if e["user_id"] == user_id]
        
        return sorted(events, key=lambda x: x["timestamp"], reverse=True)

class StabilizeMode:
    def __init__(self):
        self.is_active = False
        self.rps_limit = 1000
        self.circuit_breaker_threshold = 0.1
    
    def activate(self, rps_limit: int = 1000):
        self.is_active = True
        self.rps_limit = rps_limit
        print("🛡️  Stabilize mode activated")
    
    def deactivate(self):
        self.is_active = False
        print("✅ Stabilize mode deactivated")
    
    def should_throttle(self, current_rps: float) -> bool:
        return self.is_active and current_rps > self.rps_limit
EOF

    log_success "Audit and stabilize mode configured"
}

# Step 12: Production hardening
prod_setup() {
    log_info "🔒 Setting up production hardening..."
    
    # Create production configuration
    cat > platform/api/prod_config.py << 'EOF'
import os
from typing import Dict, Any

class ProductionConfig:
    def __init__(self):
        self.waf_rules = {
            "rate_limit_per_ip": 1000,  # requests per hour
            "max_request_size": 10 * 1024 * 1024,  # 10MB
            "blocked_headers": ["x-forwarded-for", "x-real-ip"],
            "allowed_origins": os.getenv("ALLOWED_ORIGINS", "").split(",")
        }
        
        self.backup_config = {
            "frequency": "daily",
            "retention_days": 30,
            "encryption": True,
            "pitr_enabled": True
        }
        
        self.pii_policies = {
            "retention_days": 90,
            "encryption_at_rest": True,
            "anonymization_after": 30
        }
    
    def get_waf_rules(self) -> Dict[str, Any]:
        return self.waf_rules
    
    def get_backup_config(self) -> Dict[str, Any]:
        return self.backup_config
    
    def get_pii_policies(self) -> Dict[str, Any]:
        return self.pii_policies

# Launch checklist
LAUNCH_CHECKLIST = [
    "✅ Environment variables configured",
    "✅ Database migrations applied",
    "✅ SSL certificates valid",
    "✅ Monitoring alerts configured",
    "✅ Backup procedures tested",
    "✅ Rollback procedures tested",
    "✅ Load testing completed",
    "✅ Security scan passed",
    "✅ Documentation updated",
    "✅ Team trained on procedures"
]
EOF

    log_success "Production hardening configured"
}

# Development scripts
dev_scripts() {
    log_info "🛠️  Creating development scripts..."
    
    # Create comprehensive dev script
    cat > scripts/dev.sh << 'EOF'
#!/usr/bin/env bash
set -euo pipefail

echo "🚀 Starting Anti-Fraud Platform Development Environment"

# Check dependencies
command -v pnpm >/dev/null || { echo "❌ pnpm not found. Install with: npm install -g pnpm"; exit 1; }
command -v python3 >/dev/null || { echo "❌ Python 3 not found"; exit 1; }

# Install dependencies
echo "📦 Installing dependencies..."
pnpm install
cd platform/api && pip install -r requirements.txt && cd ../..
cd platform/mobile && pnpm install && cd ../..

# Start services
echo "🌐 Starting web app..."
cd web && pnpm dev &
WEB_PID=$!

echo "🚀 Starting API server..."
cd platform/api && python -m uvicorn src.main:app --reload --host 0.0.0.0 --port 8000 &
API_PID=$!

echo "📱 Starting mobile app..."
cd platform/mobile && pnpm start &
MOBILE_PID=$!

echo "✅ All services started!"
echo "🌐 Web: http://localhost:3000"
echo "🚀 API: http://localhost:8000"
echo "📱 Mobile: Check terminal for Expo QR code"

# Cleanup function
cleanup() {
    echo "🛑 Shutting down services..."
    kill $WEB_PID $API_PID $MOBILE_PID 2>/dev/null || true
    exit 0
}

trap cleanup SIGINT SIGTERM

# Wait for services
wait
EOF

    chmod +x scripts/dev.sh
    
    # Create test script
    cat > scripts/test.sh << 'EOF'
#!/usr/bin/env bash
set -euo pipefail

echo "🧪 Running Anti-Fraud Platform Tests"

# API tests
echo "🔬 Running API tests..."
cd platform/api && python -m pytest tests/ -v --cov=src

# E2E tests
echo "🎭 Running E2E tests..."
cd ../.. && npx playwright test

# Mobile tests
echo "📱 Running mobile tests..."
cd platform/mobile && pnpm test

echo "✅ All tests completed!"
EOF

    chmod +x scripts/test.sh
    
    log_success "Development scripts created"
}

# Main execution function
main() {
    case "${1:-help}" in
        "init")
            bootstrap
            scaffold
            env_setup
            dev_scripts
            ;;
        "api")
            api_setup
            db_setup
            ;;
        "web")
            web_setup
            ;;
        "mobile")
            mobile_setup
            ;;
        "cicd")
            cicd_setup
            ;;
        "obs/slo")
            obs_setup
            slo_setup
            ;;
        "inc/audit/stab")
            incident_setup
            audit_setup
            ;;
        "prod")
            prod_setup
            ;;
        "run all")
            bootstrap
            scaffold
            env_setup
            db_setup
            api_setup
            web_setup
            mobile_setup
            cicd_setup
            obs_setup
            slo_setup
            incident_setup
            audit_setup
            prod_setup
            dev_scripts
            log_success "🎉 Full platform setup complete!"
            ;;
        "help"|*)
            echo "Usage: $0 {init|api|web|mobile|cicd|obs/slo|inc/audit/stab|prod|run all}"
            echo ""
            echo "Commands:"
            echo "  init              - Bootstrap repo + hygiene + env stubs"
            echo "  api               - API skeleton + database setup"
            echo "  web               - Web scaffold verification"
            echo "  mobile            - Mobile scaffold verification"
            echo "  cicd              - CI/CD workflows"
            echo "  obs/slo           - Observability + SLO monitoring"
            echo "  inc/audit/stab    - Incident + audit + stabilize mode"
            echo "  prod              - Production hardening"
            echo "  run all           - Execute full pipeline"
            ;;
    esac
}

# Run main function with all arguments
main "$@"
